/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * .NET 7 WebAPI - Clean Architecture
 * Clean Architecture Template for .NET 7 WebApi built with Multitenancy Support.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApiResponseOfInteger,
  ApiResponseOfObject,
  ApiResponseOfRouterConfigResponseServiceResponse,
  CheckKitStatusDto,
  CheckKitsInStockRequest,
  CheckTerminalDto,
  CreateTerminalRequest,
  ErrorResult,
  ExportTerminalRequest,
  HttpValidationProblemDetails,
  PaginationResponseOfTerminalDto,
  RemoveKitDto,
  RouterConfigRequest,
  SearchTerminalRequest,
  TerminalDto,
  TerminalKitResult,
  TerminalsCheckTerminalParams,
  TerminalsRemoveKitParams,
  TerminalsUpdateRouterConfigParams,
  TransferTerminalRequest
} from '.././model';

import { customInstance } from '.././mutator/custom-instance';
import type { ErrorType , BodyType } from '.././mutator/custom-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Search Terminal using available filters.
 */
export const terminalsSearch = (
    searchTerminalRequest: BodyType<SearchTerminalRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginationResponseOfTerminalDto>(
      {url: `/api/v1/terminals/search`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: searchTerminalRequest, signal
    },
      options);
    }
  


export const getTerminalsSearchMutationOptions = <TError = ErrorType<HttpValidationProblemDetails | ErrorResult>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsSearch>>, TError,{data: BodyType<SearchTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof terminalsSearch>>, TError,{data: BodyType<SearchTerminalRequest>}, TContext> => {

const mutationKey = ['terminalsSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminalsSearch>>, {data: BodyType<SearchTerminalRequest>}> = (props) => {
          const {data} = props ?? {};

          return  terminalsSearch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminalsSearchMutationResult = NonNullable<Awaited<ReturnType<typeof terminalsSearch>>>
    export type TerminalsSearchMutationBody = BodyType<SearchTerminalRequest>
    export type TerminalsSearchMutationError = ErrorType<HttpValidationProblemDetails | ErrorResult>

    /**
 * @summary Search Terminal using available filters.
 */
export const useTerminalsSearch = <TError = ErrorType<HttpValidationProblemDetails | ErrorResult>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsSearch>>, TError,{data: BodyType<SearchTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminalsSearch>>,
        TError,
        {data: BodyType<SearchTerminalRequest>},
        TContext
      > => {

      const mutationOptions = getTerminalsSearchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary check Terminal details.
 */
export const terminalsCheckTerminal = (
    params?: TerminalsCheckTerminalParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CheckTerminalDto>(
      {url: `/api/v1/terminals/check`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTerminalsCheckTerminalQueryKey = (params?: TerminalsCheckTerminalParams,) => {
    return [`/api/v1/terminals/check`, ...(params ? [params]: [])] as const;
    }

    
export const getTerminalsCheckTerminalQueryOptions = <TData = Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError = ErrorType<unknown>>(params?: TerminalsCheckTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTerminalsCheckTerminalQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof terminalsCheckTerminal>>> = ({ signal }) => terminalsCheckTerminal(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TerminalsCheckTerminalQueryResult = NonNullable<Awaited<ReturnType<typeof terminalsCheckTerminal>>>
export type TerminalsCheckTerminalQueryError = ErrorType<unknown>


export function useTerminalsCheckTerminal<TData = Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError = ErrorType<unknown>>(
 params: undefined |  TerminalsCheckTerminalParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsCheckTerminal>>,
          TError,
          Awaited<ReturnType<typeof terminalsCheckTerminal>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsCheckTerminal<TData = Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError = ErrorType<unknown>>(
 params?: TerminalsCheckTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsCheckTerminal>>,
          TError,
          Awaited<ReturnType<typeof terminalsCheckTerminal>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsCheckTerminal<TData = Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError = ErrorType<unknown>>(
 params?: TerminalsCheckTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary check Terminal details.
 */

export function useTerminalsCheckTerminal<TData = Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError = ErrorType<unknown>>(
 params?: TerminalsCheckTerminalParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsCheckTerminal>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTerminalsCheckTerminalQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Check if terminals exist in a specified agent or warehouse. and not linked with order item
 */
export const terminalsCheckTerminals = (
    checkKitsInStockRequest: BodyType<CheckKitsInStockRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CheckKitStatusDto[]>(
      {url: `/api/v1/terminals/check-terminals-local`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: checkKitsInStockRequest, signal
    },
      options);
    }
  


export const getTerminalsCheckTerminalsMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsCheckTerminals>>, TError,{data: BodyType<CheckKitsInStockRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof terminalsCheckTerminals>>, TError,{data: BodyType<CheckKitsInStockRequest>}, TContext> => {

const mutationKey = ['terminalsCheckTerminals'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminalsCheckTerminals>>, {data: BodyType<CheckKitsInStockRequest>}> = (props) => {
          const {data} = props ?? {};

          return  terminalsCheckTerminals(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminalsCheckTerminalsMutationResult = NonNullable<Awaited<ReturnType<typeof terminalsCheckTerminals>>>
    export type TerminalsCheckTerminalsMutationBody = BodyType<CheckKitsInStockRequest>
    export type TerminalsCheckTerminalsMutationError = ErrorType<unknown>

    /**
 * @summary Check if terminals exist in a specified agent or warehouse. and not linked with order item
 */
export const useTerminalsCheckTerminals = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsCheckTerminals>>, TError,{data: BodyType<CheckKitsInStockRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminalsCheckTerminals>>,
        TError,
        {data: BodyType<CheckKitsInStockRequest>},
        TContext
      > => {

      const mutationOptions = getTerminalsCheckTerminalsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary removeKit Terminal details.
 */
export const terminalsRemoveKit = (
    params?: TerminalsRemoveKitParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RemoveKitDto>(
      {url: `/api/v1/terminals/removekit`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getTerminalsRemoveKitQueryKey = (params?: TerminalsRemoveKitParams,) => {
    return [`/api/v1/terminals/removekit`, ...(params ? [params]: [])] as const;
    }

    
export const getTerminalsRemoveKitQueryOptions = <TData = Awaited<ReturnType<typeof terminalsRemoveKit>>, TError = ErrorType<unknown>>(params?: TerminalsRemoveKitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsRemoveKit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTerminalsRemoveKitQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof terminalsRemoveKit>>> = ({ signal }) => terminalsRemoveKit(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof terminalsRemoveKit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TerminalsRemoveKitQueryResult = NonNullable<Awaited<ReturnType<typeof terminalsRemoveKit>>>
export type TerminalsRemoveKitQueryError = ErrorType<unknown>


export function useTerminalsRemoveKit<TData = Awaited<ReturnType<typeof terminalsRemoveKit>>, TError = ErrorType<unknown>>(
 params: undefined |  TerminalsRemoveKitParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsRemoveKit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsRemoveKit>>,
          TError,
          Awaited<ReturnType<typeof terminalsRemoveKit>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsRemoveKit<TData = Awaited<ReturnType<typeof terminalsRemoveKit>>, TError = ErrorType<unknown>>(
 params?: TerminalsRemoveKitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsRemoveKit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsRemoveKit>>,
          TError,
          Awaited<ReturnType<typeof terminalsRemoveKit>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsRemoveKit<TData = Awaited<ReturnType<typeof terminalsRemoveKit>>, TError = ErrorType<unknown>>(
 params?: TerminalsRemoveKitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsRemoveKit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary removeKit Terminal details.
 */

export function useTerminalsRemoveKit<TData = Awaited<ReturnType<typeof terminalsRemoveKit>>, TError = ErrorType<unknown>>(
 params?: TerminalsRemoveKitParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsRemoveKit>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTerminalsRemoveKitQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Get Terminal details.
 */
export const terminalsGet = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TerminalDto>(
      {url: `/api/v1/terminals/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getTerminalsGetQueryKey = (id?: number,) => {
    return [`/api/v1/terminals/${id}`] as const;
    }

    
export const getTerminalsGetQueryOptions = <TData = Awaited<ReturnType<typeof terminalsGet>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTerminalsGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof terminalsGet>>> = ({ signal }) => terminalsGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof terminalsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TerminalsGetQueryResult = NonNullable<Awaited<ReturnType<typeof terminalsGet>>>
export type TerminalsGetQueryError = ErrorType<HttpValidationProblemDetails | ErrorResult>


export function useTerminalsGet<TData = Awaited<ReturnType<typeof terminalsGet>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsGet>>,
          TError,
          Awaited<ReturnType<typeof terminalsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsGet<TData = Awaited<ReturnType<typeof terminalsGet>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsGet>>,
          TError,
          Awaited<ReturnType<typeof terminalsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsGet<TData = Awaited<ReturnType<typeof terminalsGet>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Terminal details.
 */

export function useTerminalsGet<TData = Awaited<ReturnType<typeof terminalsGet>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTerminalsGetQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Delete a Terminal.
 */
export const terminalsDelete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<ApiResponseOfInteger>(
      {url: `/api/v1/terminals/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getTerminalsDeleteMutationOptions = <TError = ErrorType<HttpValidationProblemDetails | ErrorResult>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof terminalsDelete>>, TError,{id: number}, TContext> => {

const mutationKey = ['terminalsDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminalsDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  terminalsDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminalsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof terminalsDelete>>>
    
    export type TerminalsDeleteMutationError = ErrorType<HttpValidationProblemDetails | ErrorResult>

    /**
 * @summary Delete a Terminal.
 */
export const useTerminalsDelete = <TError = ErrorType<HttpValidationProblemDetails | ErrorResult>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminalsDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getTerminalsDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Create a new Terminal.
 */
export const terminalsCreate = (
    createTerminalRequest: BodyType<CreateTerminalRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TerminalKitResult[]>(
      {url: `/api/v1/terminals`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTerminalRequest, signal
    },
      options);
    }
  


export const getTerminalsCreateMutationOptions = <TError = ErrorType<HttpValidationProblemDetails | ErrorResult>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsCreate>>, TError,{data: BodyType<CreateTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof terminalsCreate>>, TError,{data: BodyType<CreateTerminalRequest>}, TContext> => {

const mutationKey = ['terminalsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminalsCreate>>, {data: BodyType<CreateTerminalRequest>}> = (props) => {
          const {data} = props ?? {};

          return  terminalsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminalsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof terminalsCreate>>>
    export type TerminalsCreateMutationBody = BodyType<CreateTerminalRequest>
    export type TerminalsCreateMutationError = ErrorType<HttpValidationProblemDetails | ErrorResult>

    /**
 * @summary Create a new Terminal.
 */
export const useTerminalsCreate = <TError = ErrorType<HttpValidationProblemDetails | ErrorResult>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsCreate>>, TError,{data: BodyType<CreateTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminalsCreate>>,
        TError,
        {data: BodyType<CreateTerminalRequest>},
        TContext
      > => {

      const mutationOptions = getTerminalsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Create a new Terminal.
 */
export const terminalsTransfer = (
    transferTerminalRequest: BodyType<TransferTerminalRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TerminalKitResult[]>(
      {url: `/api/v1/terminals/transfer`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: transferTerminalRequest, signal
    },
      options);
    }
  


export const getTerminalsTransferMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsTransfer>>, TError,{data: BodyType<TransferTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof terminalsTransfer>>, TError,{data: BodyType<TransferTerminalRequest>}, TContext> => {

const mutationKey = ['terminalsTransfer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminalsTransfer>>, {data: BodyType<TransferTerminalRequest>}> = (props) => {
          const {data} = props ?? {};

          return  terminalsTransfer(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminalsTransferMutationResult = NonNullable<Awaited<ReturnType<typeof terminalsTransfer>>>
    export type TerminalsTransferMutationBody = BodyType<TransferTerminalRequest>
    export type TerminalsTransferMutationError = ErrorType<unknown>

    /**
 * @summary Create a new Terminal.
 */
export const useTerminalsTransfer = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsTransfer>>, TError,{data: BodyType<TransferTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminalsTransfer>>,
        TError,
        {data: BodyType<TransferTerminalRequest>},
        TContext
      > => {

      const mutationOptions = getTerminalsTransferMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Export a Terminal.
 */
export const terminalsExport = (
    exportTerminalRequest: BodyType<ExportTerminalRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Blob>(
      {url: `/api/v1/terminals/export`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: exportTerminalRequest,
        responseType: 'blob', signal
    },
      options);
    }
  


export const getTerminalsExportMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsExport>>, TError,{data: BodyType<ExportTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof terminalsExport>>, TError,{data: BodyType<ExportTerminalRequest>}, TContext> => {

const mutationKey = ['terminalsExport'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminalsExport>>, {data: BodyType<ExportTerminalRequest>}> = (props) => {
          const {data} = props ?? {};

          return  terminalsExport(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminalsExportMutationResult = NonNullable<Awaited<ReturnType<typeof terminalsExport>>>
    export type TerminalsExportMutationBody = BodyType<ExportTerminalRequest>
    export type TerminalsExportMutationError = ErrorType<unknown>

    /**
 * @summary Export a Terminal.
 */
export const useTerminalsExport = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsExport>>, TError,{data: BodyType<ExportTerminalRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminalsExport>>,
        TError,
        {data: BodyType<ExportTerminalRequest>},
        TContext
      > => {

      const mutationOptions = getTerminalsExportMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Get the router configuration for a terminal.
 */
export const terminalsGetRouterConfig = (
    configId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiResponseOfObject>(
      {url: `/api/v1/terminals/get-router-config/${configId}`, method: 'GET', signal
    },
      options);
    }
  

export const getTerminalsGetRouterConfigQueryKey = (configId?: string,) => {
    return [`/api/v1/terminals/get-router-config/${configId}`] as const;
    }

    
export const getTerminalsGetRouterConfigQueryOptions = <TData = Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(configId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTerminalsGetRouterConfigQueryKey(configId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof terminalsGetRouterConfig>>> = ({ signal }) => terminalsGetRouterConfig(configId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(configId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TerminalsGetRouterConfigQueryResult = NonNullable<Awaited<ReturnType<typeof terminalsGetRouterConfig>>>
export type TerminalsGetRouterConfigQueryError = ErrorType<HttpValidationProblemDetails | ErrorResult>


export function useTerminalsGetRouterConfig<TData = Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 configId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsGetRouterConfig>>,
          TError,
          Awaited<ReturnType<typeof terminalsGetRouterConfig>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsGetRouterConfig<TData = Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 configId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof terminalsGetRouterConfig>>,
          TError,
          Awaited<ReturnType<typeof terminalsGetRouterConfig>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useTerminalsGetRouterConfig<TData = Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 configId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get the router configuration for a terminal.
 */

export function useTerminalsGetRouterConfig<TData = Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError = ErrorType<HttpValidationProblemDetails | ErrorResult>>(
 configId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof terminalsGetRouterConfig>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTerminalsGetRouterConfigQueryOptions(configId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update the router configuration for a terminal.
 */
export const terminalsUpdateRouterConfig = (
    routerId: string,
    routerConfigRequest: BodyType<RouterConfigRequest>,
    params?: TerminalsUpdateRouterConfigParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ApiResponseOfRouterConfigResponseServiceResponse>(
      {url: `/api/v1/terminals/update-router-config/${routerId}`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: routerConfigRequest,
        params, signal
    },
      options);
    }
  


export const getTerminalsUpdateRouterConfigMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsUpdateRouterConfig>>, TError,{routerId: string;data: BodyType<RouterConfigRequest>;params?: TerminalsUpdateRouterConfigParams}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof terminalsUpdateRouterConfig>>, TError,{routerId: string;data: BodyType<RouterConfigRequest>;params?: TerminalsUpdateRouterConfigParams}, TContext> => {

const mutationKey = ['terminalsUpdateRouterConfig'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof terminalsUpdateRouterConfig>>, {routerId: string;data: BodyType<RouterConfigRequest>;params?: TerminalsUpdateRouterConfigParams}> = (props) => {
          const {routerId,data,params} = props ?? {};

          return  terminalsUpdateRouterConfig(routerId,data,params,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TerminalsUpdateRouterConfigMutationResult = NonNullable<Awaited<ReturnType<typeof terminalsUpdateRouterConfig>>>
    export type TerminalsUpdateRouterConfigMutationBody = BodyType<RouterConfigRequest>
    export type TerminalsUpdateRouterConfigMutationError = ErrorType<unknown>

    /**
 * @summary Update the router configuration for a terminal.
 */
export const useTerminalsUpdateRouterConfig = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof terminalsUpdateRouterConfig>>, TError,{routerId: string;data: BodyType<RouterConfigRequest>;params?: TerminalsUpdateRouterConfigParams}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof terminalsUpdateRouterConfig>>,
        TError,
        {routerId: string;data: BodyType<RouterConfigRequest>;params?: TerminalsUpdateRouterConfigParams},
        TContext
      > => {

      const mutationOptions = getTerminalsUpdateRouterConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    